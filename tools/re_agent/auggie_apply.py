#!/usr/bin/env python3
"""
Auggie Integration for RE-Agent

This script reads artifacts generated by RE-Agent and uses Auggie CLI
to apply the changes using proper code editing tools.

Usage:
    # Apply a single function implementation
    python auggie_apply.py --function IMP_ISP_AddSensor
    
    # Apply all pending artifacts
    python auggie_apply.py --apply-all
    
    # Dry-run mode (show what would be done)
    python auggie_apply.py --function IMP_ISP_AddSensor --dry-run
"""

import os
import sys
import json
import argparse
import subprocess
from pathlib import Path
from typing import Dict, Any, Optional, Tuple


def find_auggie() -> Optional[str]:
    """Find auggie executable."""
    # Check if auggie is in PATH
    result = subprocess.run(['which', 'auggie'], capture_output=True, text=True)
    if result.returncode == 0:
        return result.stdout.strip()
    
    # Check common npm global install locations
    npm_paths = [
        Path.home() / '.npm-global' / 'bin' / 'auggie',
        Path.home() / '.nvm' / 'versions' / 'node' / '*' / 'bin' / 'auggie',
        '/usr/local/bin/auggie',
    ]
    
    for path in npm_paths:
        if '*' in str(path):
            # Handle glob patterns
            import glob
            matches = glob.glob(str(path))
            if matches:
                return matches[0]
        elif Path(path).exists():
            return str(path)
    
    return None


def call_auggie(prompt: str, dry_run: bool = False) -> tuple[bool, str]:
    """
    Call Auggie CLI with a prompt.
    
    Args:
        prompt: The prompt to send to Auggie
        dry_run: If True, just print what would be done
        
    Returns:
        Tuple of (success, output)
    """
    auggie_path = find_auggie()
    
    if not auggie_path:
        return False, "Auggie CLI not found. Install with: npm install -g @augmentcode/auggie"
    
    if dry_run:
        print(f"\n[DRY RUN] Would call Auggie with prompt:")
        print("=" * 80)
        print(prompt)
        print("=" * 80)
        return True, "Dry run - no changes made"
    
    # Call auggie with the prompt
    # Use --print flag to pass the prompt as an argument instead of stdin
    # Use --quiet to reduce output noise
    # Use --max-turns to limit agentic iterations (increased to 15 for complex edits)
    print(f"  Calling Auggie CLI (timeout: 180s, max-turns: 15)...")
    try:
        result = subprocess.run(
            [auggie_path, "--print", "--quiet", "--max-turns", "15", prompt],
            capture_output=True,
            text=True,
            timeout=180,  # 3 minute timeout
            cwd=os.getcwd()  # Run in current directory
        )

        if result.returncode == 0:
            # Check if Auggie hit max-turns limit
            if "maximum iterations reached" in result.stdout or "maximum iterations reached" in result.stderr:
                print(f"  ⚠ Auggie hit max-turns limit - edit may be incomplete")
                # Still return success but with a warning in the message
                return True, f"Warning: Max turns reached. Output: {result.stdout}"
            else:
                print(f"  Auggie completed successfully")
                return True, result.stdout
        else:
            print(f"  Auggie failed with return code {result.returncode}")
            return False, f"Auggie failed: {result.stderr}"

    except subprocess.TimeoutExpired:
        print(f"  Auggie timed out after 120 seconds")
        return False, "Auggie timed out after 2 minutes"
    except Exception as e:
        print(f"  Error calling Auggie: {e}")
        return False, f"Error calling Auggie: {e}"


def verify_compilation(src_file: str) -> Tuple[bool, str]:
    """
    Verify that a source file compiles without errors.

    Args:
        src_file: Path to the source file to verify

    Returns:
        Tuple of (success: bool, message: str)
    """
    # Check if we're in the openimp project
    if not os.path.exists("Makefile"):
        return True, "No Makefile found - skipping compilation verification"

    # Try to compile just this file
    print(f"  Verifying compilation of {src_file}...")

    try:
        # Use make to compile just this file (dry-run to check syntax)
        result = subprocess.run(
            ["make", "-n", src_file.replace(".c", ".o")],
            capture_output=True,
            text=True,
            timeout=10
        )

        # If make -n succeeds, try actual compilation
        if result.returncode == 0:
            result = subprocess.run(
                ["make", src_file.replace(".c", ".o")],
                capture_output=True,
                text=True,
                timeout=30
            )

            if result.returncode == 0:
                print(f"  ✓ Compilation successful")
                return True, "Compilation successful"
            else:
                # Extract error messages
                errors = result.stderr if result.stderr else result.stdout
                print(f"  ✗ Compilation failed:")
                print(f"    {errors[:500]}")
                return False, f"Compilation failed: {errors[:200]}"
        else:
            return True, "Cannot verify compilation (no make rule)"

    except subprocess.TimeoutExpired:
        return False, "Compilation verification timed out"
    except Exception as e:
        return True, f"Cannot verify compilation: {e}"


def apply_function_implementation(artifact_file, dry_run: bool = False, verify: bool = True):
    """
    Apply a function implementation using Auggie.

    Args:
        artifact_file: Path to the JSON artifact file (str or Path)
        dry_run: If True, show what would be done without making changes

    Returns:
        Tuple of (success: bool, message: str)
    """
    # Convert to Path if string
    if isinstance(artifact_file, str):
        artifact_file = Path(artifact_file)

    print(f"\n{'[DRY RUN] ' if dry_run else ''}Applying function implementation from {artifact_file.name}")
    
    # Load artifact
    with open(artifact_file, 'r') as f:
        artifact = json.load(f)
    
    function_name = artifact['function_name']
    implementation = artifact['implementation']
    notes = artifact.get('notes', '')
    
    # Infer source file from function name
    parts = function_name.split('_', 2)
    if len(parts) < 3 or parts[0] != 'IMP':
        msg = f"Cannot infer source file from function name: {function_name}"
        print(f"  ✗ {msg}")
        return False, msg

    module = parts[1]
    src_mapping = {
        'OSD': 'src/imp_osd.c',
        'Encoder': 'src/imp_encoder.c',
        'System': 'src/imp_system.c',
        'ISP': 'src/imp_isp.c',
        'IVS': 'src/imp_ivs.c',
        'Audio': 'src/imp_audio.c',
        'FrameSource': 'src/imp_framesource.c',
    }

    src_file = src_mapping.get(module)
    if not src_file:
        msg = f"Unknown module: {module}"
        print(f"  ✗ {msg}")
        return False, msg
    
    # Create prompt for Auggie - simplified and more direct
    prompt = f"""Replace the entire `{function_name}` function in `{src_file}` with this implementation:

```c
{implementation}
```

Use str-replace-editor to replace the function body. Keep any existing comments above the function.
"""
    
    success, output = call_auggie(prompt, dry_run)

    if success:
        # Verify the edit was applied (check if file was modified)
        if not dry_run and os.path.exists(src_file):
            # Simple verification: check if function name exists in file
            with open(src_file, 'r') as f:
                content = f.read()
                if function_name in content:
                    msg = f"Successfully applied {function_name}"
                    print(f"  ✓ {msg}")
                    if "Warning: Max turns" in output:
                        print(f"    ⚠ Note: Auggie hit max-turns limit, please verify the edit manually")

                    # Verify compilation if requested
                    if verify:
                        compile_success, compile_msg = verify_compilation(src_file)
                        if not compile_success:
                            print(f"  ⚠ Compilation verification failed: {compile_msg}")
                            print(f"    You may need to manually fix compilation errors")
                            return True, f"{msg} (with compilation warnings)"

                    return True, msg
                else:
                    msg = f"Function {function_name} not found in {src_file} after edit"
                    print(f"  ⚠ {msg}")
                    return False, msg
        else:
            msg = f"Successfully applied {function_name}"
            print(f"  ✓ {msg}")
            if not dry_run:
                print(f"    Output: {output[:200]}...")
            return True, msg
    else:
        msg = f"Failed to apply {function_name}: {output}"
        print(f"  ✗ {msg}")
        return False, msg


def apply_struct_update(artifact_file, dry_run: bool = False, verify: bool = True):
    """
    Apply a struct definition update using Auggie.

    Args:
        artifact_file: Path to the JSON artifact file (str or Path)
        dry_run: If True, show what would be done without making changes
        verify: If True, verify compilation after applying changes

    Returns:
        Tuple of (success: bool, message: str)
    """
    # Convert to Path if string
    if isinstance(artifact_file, str):
        artifact_file = Path(artifact_file)

    print(f"\n{'[DRY RUN] ' if dry_run else ''}Applying struct update from {artifact_file.name}")
    
    # Load artifact
    with open(artifact_file, 'r') as f:
        artifact = json.load(f)
    
    struct_name = artifact['struct_name']
    src_file = artifact['src_file']
    proposed_def = artifact['proposed_definition']
    offsets = artifact.get('discovered_offsets', {})
    
    # Create prompt for Auggie - simplified and more direct
    prompt = f"""Update the `{struct_name}` struct definition in `{src_file}` to match this layout:

```c
{proposed_def}
```

The struct must have these members at these offsets:
{json.dumps(offsets, indent=2)}

Use str-replace-editor to replace the struct definition. Keep any existing comments.
"""
    
    success, output = call_auggie(prompt, dry_run)

    if success:
        # Verify the edit was applied (check if struct exists in file)
        if not dry_run and os.path.exists(src_file):
            # Simple verification: check if struct name exists in file
            with open(src_file, 'r') as f:
                content = f.read()
                if struct_name in content:
                    msg = f"Successfully updated {struct_name}"
                    print(f"  ✓ {msg}")
                    if "Warning: Max turns" in output:
                        print(f"    ⚠ Note: Auggie hit max-turns limit, please verify the edit manually")

                    # Verify compilation if requested
                    if verify:
                        compile_success, compile_msg = verify_compilation(src_file)
                        if not compile_success:
                            print(f"  ⚠ Compilation verification failed: {compile_msg}")
                            print(f"    You may need to manually fix compilation errors")
                            return True, f"{msg} (with compilation warnings)"

                    return True, msg
                else:
                    msg = f"Struct {struct_name} not found in {src_file} after edit"
                    print(f"  ⚠ {msg}")
                    return False, msg
        else:
            msg = f"Successfully updated {struct_name}"
            print(f"  ✓ {msg}")
            if not dry_run:
                print(f"    Output: {output[:200]}...")
            return True, msg
    else:
        msg = f"Failed to update {struct_name}: {output}"
        print(f"  ✗ {msg}")
        return False, msg


def main():
    parser = argparse.ArgumentParser(description="Apply RE-Agent artifacts using Auggie CLI")
    parser.add_argument("--function", "-f", help="Function name to apply (e.g., IMP_ISP_AddSensor)")
    parser.add_argument("--struct", "-s", help="Struct name to update (e.g., ISPDevice)")
    parser.add_argument("--apply-all", "-a", action="store_true", help="Apply all pending artifacts")
    parser.add_argument("--dry-run", "-n", action="store_true", help="Show what would be done without making changes")
    parser.add_argument("--artifacts-dir", "-d", default="tools/re_agent/full_review_output/auggie_artifacts",
                        help="Directory containing artifacts (default: tools/re_agent/full_review_output/auggie_artifacts)")
    
    args = parser.parse_args()
    
    if not any([args.function, args.struct, args.apply_all]):
        parser.print_help()
        print("\nError: Must specify --function, --struct, or --apply-all")
        return 1
    
    artifacts_dir = Path(args.artifacts_dir)
    if not artifacts_dir.exists():
        print(f"Error: Artifacts directory not found: {artifacts_dir}")
        print("Run RE-Agent first to generate artifacts")
        return 1
    
    success_count = 0
    fail_count = 0
    
    if args.function:
        artifact_file = artifacts_dir / f"{args.function}.json"
        if not artifact_file.exists():
            print(f"Error: Artifact not found: {artifact_file}")
            return 1

        success, _ = apply_function_implementation(artifact_file, args.dry_run)
        if success:
            success_count += 1
        else:
            fail_count += 1

    if args.struct:
        artifact_file = artifacts_dir / f"{args.struct}_update.json"
        if not artifact_file.exists():
            print(f"Error: Artifact not found: {artifact_file}")
            return 1

        success, _ = apply_struct_update(artifact_file, args.dry_run)
        if success:
            success_count += 1
        else:
            fail_count += 1

    if args.apply_all:
        # Apply all function implementations
        for artifact_file in artifacts_dir.glob("*.json"):
            if artifact_file.name.endswith("_update.json"):
                # Struct update
                success, _ = apply_struct_update(artifact_file, args.dry_run)
                if success:
                    success_count += 1
                else:
                    fail_count += 1
            else:
                # Function implementation
                success, _ = apply_function_implementation(artifact_file, args.dry_run)
                if success:
                    success_count += 1
                else:
                    fail_count += 1
    
    print(f"\n{'[DRY RUN] ' if args.dry_run else ''}Summary: {success_count} succeeded, {fail_count} failed")
    return 0 if fail_count == 0 else 1


if __name__ == "__main__":
    sys.exit(main())

